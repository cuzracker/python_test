알고리즘에 대한 두 가지 중요한 질문
1. 정확성 - 모든 입력 사례에 대해서 해답을 찾을 수 있는가
2. 효율성 - 입력 크기가 커지면 성능이 어떻게 변화하는가, 함수 f(x)로 표현 가능


알고리즘의 분석
1. 정확적 분석: 모든 입력 사례에 대해서 정확한 해답을 찾는다는 것을 증명
2. 효율성 분석: 입력 크기가 커지는 정도에 따라 성능의 변화량을 증명
    - 시간 복잡도(time complexity): 시간을 기준으로 알고리즘의 효율성 분석
    - 공간 복잡도(space complexity): 공간을 기준으로 알고리즘의 효율성 분석


알고리즘의 성능 분석
1. 퍼포먼스 측정: 실행 시간을 직접 측정 or 실행 명령의 숫자 세기
    - 컴퓨터의 성능이나 프로그래밍 언어에 따라 달라짐
2. 복잡도 분석: 컴퓨터나 프로그래밍 언어와 무관하게 성능 분석
    - 입력 크기에 따른 단위 연산의 실행 횟수 세기

----------------------------------------------------------------------

시간 복잡도 분석
1. 단위 연산: 알고리즘 실행의 기본이 되는 명령어들의 집합
2. 입력 크기(Input size): 문제가 가진 파라미터, 입력 사례의 크기


1.2
def sum(S):
    n = len(S)
    result = 0
    for i in range(n):
        result += S[i]
    return result

- 단위 연산: 리스트의 원소를 result에 더하는 명령
- 입력 크기: 리스트 S의 원소 개수(n)
- for 문장은 항상 n번 실행하므로 다음과 같이 표현
  시간 복잡도: T(n) = n

1.3
def exchange(S):
    n = len(S)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if(S[i] > S[j]):
                S[i], S[j] = S[j], S[i]

- 단위 연산: S[i]와 S[j]의 비교
- 입력 크기: 정렬할 리스트 S의 원소 개수(n)
- for-j 루프는 i에 따라 n - 1번에서 1번까지 실행하르로 다음과 같이 계산
  시간복잡도: T(n) = (n - 1) + (n - 2) + ... + 1 = (n - 1)n / 2


1.4
def matrixmult(n, A, B):
    C = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            for k in range(n):
                C[i][j] += A[i][k] * B[k][j]
    reutrn C

- 단위 연산: 가장 안쪽 for 루프에 있는 곱셈
- 입력 크기: 행과 열의 개수(n)
- 3중 for 루프가 항상 n번 실행하므로 다음과 같이 계산
  시간 복잡도: T(n) = n x n x n = n^3

----------------------------------------------------------------------

입력 사례에 따른 시간 복잡도 분석
1. 일정 시간 복잡도: 입력 사례에 따라 달라지지 않는 경우
2. 최악, 최적, 평균 시간 복잡도 분석: 입력 사례에 따라 달라지는 경우
   (실무에선 평균의 경우, 연구/논문에선 최악의 경우)


1.1(순차 탐색)의 시간 복잡도 분석
- 단위 연산: 리스트의 원소와 주어진 키 x와의 비교 연산
- 입력 크기: 리스트 원소의 개수(n)
- 최악의 경우는 모두 비교: W(n) = n
- 최적의 경우는 한 번만 비교: B(n) = 1
- 평균의 경유: 주어진 키 x가 k번째에 있으면 k번을 비교함
  (만약 어떤 키 x는 리스트 S에 골고루 분포해 있다고 한다면)
  A(n) = (n + 1) / 2

----------------------------------------------------------------------

어떤 알고리즘이 (궁극적으로) 더 빠른가?
1. 시간 복잡도: 입력 크기(n)에 대한 단위 연산 횟수의 함수 f(n)
2. 시간 복잡도가 f_1(n) = n인 알고리즘과 f_2(n) = n^2인 알고리즘
    - n이 1000보다 크면 f_1(1차식)이 f_2(2차식)보다 궁극적으로 더 빠름


차수(Order): 알고리즘의 궁극적인 성능 분류
- 1차 시간 알고리즘: 시간 복잡도가 1차 함수인 알고리즘
- 2차 시간 알고리즘: 시간 복잡도가 2차 함수인 알고리즘
- 근본 원리: 모든 1차 시간 알고리즘은 궁극적으로 2차 시간 알고리즘보다 빠름
- 시간 복잡도 함수의 차수로 알고리즘의 성능을 분류


자주 사용되는 복잡도 분류
(복잡도 함수 - 분류 이름 - 대분류)
1. 1 - 상수 시간 - 다항 시간(polynomial)
2. lgn - 로그 시간 - 다항 시간
3. n - 선형 시간 - 다항 시간
4. nlgn - 선형-로그 시간 - 다항 시간
5. n^2 - 2차 시간 - 다항 시간
6. n^3 - 3차 시간 - 다항 시간
7. 2^n - 지수 시간 - 지수 시간(exponential)
8. n! - 팩토리얼 시간 - 지수 시간


알고리즘의 성능을 차수로 분류하는 법
- 복잡도 함수를 분류할 때 낮은 차수의 항들은 항상 버릴 수 있음
- 예를 들어, an^2 + bn + c의 함수를 2차 시간 함수(n^2)로 분류
- (궁극적으로) 2차 항이 이 함수의 값을 결정하는데 가장 중요함


점근적 표기법: O, θ, Ω
1. Big-O: 복잡도 함수의 점근적 상한(upperbound)을 표기
2. 오메가(Ω): 복잡도 함수의 점근적 하한을 표기
3. 세타(θ): 차수: 복잡도 함수의 점근적 상한과 하한을 동시에 만족


1.3(교환 정렬)의 차수
- T(n) = (n - 1)n / 2 = 1/2 * n^2 - 1/2 * n
- T(n) ∈ O(n^2), T(n) ∈ Ω(n^2), T(n) ∈ θ(n^2)
  그러므로, 교환 정렬 알고리즘의 차수는 θ(n^2)


1.1(순차 탐색)의 차수
- 최악의 경우: W(n) = n ∈ θ(n)
- 최적의 경우: B(n) = 1 ∈ θ(1)
- 평균의 경유: A(n) = (n + 1) / 2 ∈ θ(n)
- 최악과 평균이 같음
